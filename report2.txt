EE 108B Processor Datapath Design - LAB2

Charles Guan
Nipun Agarwala

11th February, 2014

INTRODUCTION:
The pong program first draws a ball at a initialized X and Y coordinate position and a paddle at the corresponding Y coordinate but on the left edge. Then, it iterates through the same position 5 times till the counter is greater than the max value. At that moment, the ball is cleared and the program updates the position of the ball by incrementing the X and Y Coordinates of the ball by +/-1 pixel each, depending on which direction the ball is moving towards. That is, on reaching the maximum value of any of the coordinates, the ball starts incrementing the coodrinates by -1 and on reaching the minimum, it increments the coordinates by +1. Immediately, the position of the paddle is updated to be centred using the position of the ball. To update the paddle, we delete one square from one end of the paddle and draw one square on the other end of the paddle. This loop then proceeds as before.

DESIGN:
We decided on having only the main functions called and the counter incremented by the game loop. For that reason, we incorporated the counter loop, draw ball, update paddle, clear ball and set position in the game loop. Since the position of the ball was being used by the paddle, we decided to allocate two registers to hold the X and Y coordinates of the ball respectively. These registers were updated regularly with the most current position of the ball and thus allowed the paddle to update its position respectively. We also stored the direction of increment and the counter is specific registers to keep a permanent track of them.

Since we were drawing squares for both the ball and paddle, we created a special write_square function that updated the required registers with the bytes to be written and then wrote the bytes. Hence, we only needed to set the location and do the edge case checking in the other functions. To make sure that the pixels were shifting slow enough for the eyes to detect, we made every position loop 5 times before updating the position of the ball and paddle. Once the counter was more than the maximum, we called the clear_ball, set_position and update_paddle functions.

The clear_ball function wrote the bytes of he current position of the ball but in black so that the ball blended into the surrounding. Then we checked whether the current position of the ball is on either of the edges. If so, we changed the direction of the ball stored in the respective registers by flipping the sign of the incremental value. After this checking, we update the position of the ball by adding the confirmed incremental values to the current position of the ball and then store them in their respective registers. 

Finally, we update the position of the paddle. Using the current Y coordinate of the ball, the paddle is tried to be centered on the left edge of the screen. But this depends on whether the paddle is at the edges. If the top square of the paddle touches the top edge or the bottom square tocuhes the bottom, the paddle is not moved until the ball is higher than half the square height below or above the edges. After the edge cases are checked, we change the position of the paddle by deleting one square at one edge and adding another on the other edge. If the ball is moving upwards, then the bottom-most square is blackened and one added at the top and vice-versa.

After the paddle is updated, the game loop resumes as before and the infinite pong match continues!

RESULTS:
Three major components of the processor were implemented beyond the starter code, along with the testbench instruction set. 

Drawing the initial stationary paddle and ball proved to be simple. These were implented by short write byte loops. However, to create motion, it is necessary to erase and track the ball and paddle while simultaneously re-drawing them. We stored the locations of both in global variables. For self-playing pong, the y-coordinates of each are matched, so this could be stored in a single variable.
Other issues included coordinate bounding on the paddle when the ball was moving. Since the paddle could not be drawn off the screen that the ball moved upon, it was necessary to ensure that the paddle would stop moving at its edge even though the ball might move for a couple more squares. This required bounds-checking to fix.
The initial design had issues with speed updating the paddle and ball, resulting in visibly flickering paddles and balls. This was caused by the implementation taking large amounts of time to refresh the new images of the ball and paddle. After reviewing the code, it was understood that performance could be enhanced by changing how the paddle was erase and re-written. Out of simplicity, the original implementation erased the entire paddle at each iteration, and then re-drew the entire paddle, which was time-consuming given that 6 paddle blocks and 1 ball block had to be re-drawn each time. To take advantage of the fact that the ball and paddle would only move once in any direction at any iteration, the final implementation draws only one block for the paddle's leading edge (as relative to the paddle motion) and erases only one block for the paddle's tail edge at each iteration. This speeds up the refresh time by about 3.5 times, as the time-consuming number of blocks to erase and redraw is cut down to two.

CONCLUSIONS:
The pong simulation, built on top of a Python graphics display, can move at a wide range of speeds without flickering. Furthermore, it will robustly play itself forever. The program was well-designed, drawing on the high-level functions that might be used in high-level language implementations. This mindset guided us to appropriate function decomposition that was tedious at first but led to simplified implementaiton later. Because functions in assembly require explicit stack allocation and register saving, we were more wary of unnecessary decomposition.
The program was well-implemented, integrating the ball motion and the paddle motion well with shared variables on the stack. The implementation left room to make extensions flexible. For example, allowing users to control the paddle would simply require reading from the input and jumping to the move_up and move_down modules within the update_paddle function.
Possible changes for next time could include storing global variables on the gp pointer or on the stack.

